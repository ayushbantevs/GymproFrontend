/**
 * @fileoverview added by tsickle
 * Generated from: lib/component/mat-google-maps-autocomplete.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, ElementRef, EventEmitter, Input, NgZone, Output, ViewChild } from '@angular/core';
import { FormControl, Validators } from '@angular/forms';
import { MapsAPILoader } from '@agm/core';
import { MatValidateAddressDirective } from '../directives/address-validator/mat-address-validator.directive';
/** @enum {string} */
const Appearance = {
    STANDARD: "standard",
    FILL: "fill",
    OUTLINE: "outline",
    LEGACY: "legacy",
};
export { Appearance };
export class MatGoogleMapsAutocompleteComponent {
    /**
     * @param {?} mapsAPILoader
     * @param {?} ngZone
     */
    constructor(mapsAPILoader, ngZone) {
        this.mapsAPILoader = mapsAPILoader;
        this.ngZone = ngZone;
        this.addressLabelText = 'Address';
        this.placeholderText = 'Please enter the address';
        this.requiredErrorText = 'The address is required';
        this.invalidErrorText = 'The address is not valid';
        this.appearance = Appearance.STANDARD;
        this.autoCompleteOptions = {};
        this.onChange = new EventEmitter();
        this.onAutocompleteSelected = new EventEmitter();
        this.onGermanAddressMapped = new EventEmitter();
        this.onLocationSelected = new EventEmitter();
        this.onNewPlaceResult = new EventEmitter();
        this.addressValidator = new MatValidateAddressDirective();
        this.addressSearchControl = new FormControl({ value: null }, Validators.compose([
            Validators.required,
            this.addressValidator.validate()
        ]));
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.addressValidator.subscribe(this.onNewPlaceResult);
        /** @type {?} */
        const options = {
            // types: ['address'],
            // componentRestrictions: {country: this.country},
            placeIdOnly: this.placeIdOnly,
            strictBounds: this.strictBounds,
            // types: this.types,
            type: this.type
        };
        // tslint:disable-next-line:no-unused-expression
        this.country ? options.componentRestrictions = { country: this.country } : null;
        // tslint:disable-next-line:no-unused-expression
        this.country ? options.types = this.types : null;
        this.autoCompleteOptions = Object.assign(this.autoCompleteOptions, options);
        this.initGoogleMapsAutocomplete();
    }
    /**
     * @return {?}
     */
    initGoogleMapsAutocomplete() {
        this.mapsAPILoader
            .load()
            .then((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const autocomplete = new google.maps.places.Autocomplete(this.searchElementRef.nativeElement, this.autoCompleteOptions);
            autocomplete.addListener('place_changed', (/**
             * @return {?}
             */
            () => {
                this.ngZone.run((/**
                 * @return {?}
                 */
                () => {
                    // get the place result
                    /** @type {?} */
                    const place = autocomplete.getPlace();
                    /** @type {?} */
                    const germanAddress = {
                        gmID: place.id,
                        icon: place.icon,
                        url: place.url,
                        placeID: place.place_id,
                        displayAddress: place.formatted_address,
                        name: place.name,
                        vicinity: place.vicinity,
                        locality: {},
                        state: {},
                        country: {},
                        geoLocation: { latitude: -1, longitude: -1 },
                    };
                    if (place.geometry && place.geometry.location) {
                        germanAddress.geoLocation.latitude = place.geometry.location.lat();
                        germanAddress.geoLocation.longitude = place.geometry.location.lng();
                    }
                    place.address_components.forEach((/**
                     * @param {?} value
                     * @return {?}
                     */
                    value => {
                        if (value.types.indexOf('street_number') > -1) {
                            germanAddress.streetNumber = Number(value.short_name);
                        }
                        if (value.types.indexOf('route') > -1) {
                            germanAddress.streetName = value.long_name;
                        }
                        if (value.types.indexOf('postal_code') > -1) {
                            germanAddress.postalCode = Number(value.short_name);
                        }
                        if (value.types.indexOf('sublocality') > -1) {
                            germanAddress.sublocality = value.long_name;
                        }
                        if (value.types.indexOf('locality') > -1) {
                            germanAddress.locality.long = value.long_name;
                            germanAddress.locality.short = value.short_name;
                        }
                        if (value.types.indexOf('administrative_area_level_1') > -1) {
                            germanAddress.state.long = value.long_name;
                            germanAddress.state.short = value.short_name;
                        }
                        if (value.types.indexOf('country') > -1) {
                            germanAddress.country.long = value.long_name;
                            germanAddress.country.short = value.short_name;
                        }
                        if (value.types.indexOf('administrative_area_level_3') > -1) {
                            germanAddress.locality.short = value.short_name;
                        }
                    }));
                    this.onGermanAddressMapped.emit(germanAddress);
                    if (!place.place_id || place.geometry === undefined || place.geometry === null) {
                        // place result is not valid
                        return;
                    }
                    else {
                        // show dialog to select a address from the input
                        // emit failed event
                    }
                    this.address = place.formatted_address;
                    this.onAutocompleteSelected.emit(place);
                    // console.log('onAutocompleteSelected -> ', place);
                    this.onLocationSelected.emit({
                        latitude: place.geometry.location.lat(),
                        longitude: place.geometry.location.lng()
                    });
                }));
            }));
        }))
            .catch((/**
         * @param {?} err
         * @return {?}
         */
        (err) => console.log(err)));
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onQuery(event) {
        // console.log('onChange()', event);
        this.onChange.emit(this.address);
    }
    /**
     * @private
     * @return {?}
     */
    resetAddress() {
        this.address = null;
        this.addressSearchControl.updateValueAndValidity();
    }
}
MatGoogleMapsAutocompleteComponent.decorators = [
    { type: Component, args: [{
                selector: 'mat-google-maps-autocomplete',
                exportAs: 'matGoogleMapsAutocomplete',
                template: "<mat-form-field class=\"full-width\" [appearance]=\"appearance\">\n  <mat-label>{{addressLabelText}}</mat-label>\n  <input matInput\n         [(ngModel)]=\"address\"\n         (change)=\"onQuery($event)\"\n         placeholder=\"{{placeholderText}}\"\n         class=\"form-control\"\n         #search\n         MatValidateAddress\n         required>\n  <mat-error *ngIf=\"addressSearchControl.hasError('required')\">\n    {{requiredErrorText}}\n  </mat-error>\n  <mat-error *ngIf=\"addressSearchControl.hasError('validateAddress')\">\n    {{invalidErrorText}}\n  </mat-error>\n</mat-form-field>\n",
                styles: [".full-width{width:100%}"]
            }] }
];
/** @nocollapse */
MatGoogleMapsAutocompleteComponent.ctorParameters = () => [
    { type: MapsAPILoader },
    { type: NgZone }
];
MatGoogleMapsAutocompleteComponent.propDecorators = {
    searchElementRef: [{ type: ViewChild, args: ['search', { static: false },] }],
    addressLabelText: [{ type: Input }],
    placeholderText: [{ type: Input }],
    requiredErrorText: [{ type: Input }],
    invalidErrorText: [{ type: Input }],
    appearance: [{ type: Input }],
    address: [{ type: Input }],
    country: [{ type: Input }],
    placeIdOnly: [{ type: Input }],
    strictBounds: [{ type: Input }],
    types: [{ type: Input }],
    type: [{ type: Input }],
    autoCompleteOptions: [{ type: Input }],
    onChange: [{ type: Output }],
    onAutocompleteSelected: [{ type: Output }],
    onGermanAddressMapped: [{ type: Output }],
    onLocationSelected: [{ type: Output }]
};
if (false) {
    /** @type {?} */
    MatGoogleMapsAutocompleteComponent.prototype.searchElementRef;
    /** @type {?} */
    MatGoogleMapsAutocompleteComponent.prototype.addressLabelText;
    /** @type {?} */
    MatGoogleMapsAutocompleteComponent.prototype.placeholderText;
    /** @type {?} */
    MatGoogleMapsAutocompleteComponent.prototype.requiredErrorText;
    /** @type {?} */
    MatGoogleMapsAutocompleteComponent.prototype.invalidErrorText;
    /** @type {?} */
    MatGoogleMapsAutocompleteComponent.prototype.appearance;
    /** @type {?} */
    MatGoogleMapsAutocompleteComponent.prototype.address;
    /** @type {?} */
    MatGoogleMapsAutocompleteComponent.prototype.country;
    /** @type {?} */
    MatGoogleMapsAutocompleteComponent.prototype.placeIdOnly;
    /** @type {?} */
    MatGoogleMapsAutocompleteComponent.prototype.strictBounds;
    /** @type {?} */
    MatGoogleMapsAutocompleteComponent.prototype.types;
    /** @type {?} */
    MatGoogleMapsAutocompleteComponent.prototype.type;
    /** @type {?} */
    MatGoogleMapsAutocompleteComponent.prototype.autoCompleteOptions;
    /** @type {?} */
    MatGoogleMapsAutocompleteComponent.prototype.onChange;
    /** @type {?} */
    MatGoogleMapsAutocompleteComponent.prototype.onAutocompleteSelected;
    /** @type {?} */
    MatGoogleMapsAutocompleteComponent.prototype.onGermanAddressMapped;
    /** @type {?} */
    MatGoogleMapsAutocompleteComponent.prototype.onLocationSelected;
    /**
     * @type {?}
     * @private
     */
    MatGoogleMapsAutocompleteComponent.prototype.onNewPlaceResult;
    /**
     * @type {?}
     * @private
     */
    MatGoogleMapsAutocompleteComponent.prototype.addressValidator;
    /** @type {?} */
    MatGoogleMapsAutocompleteComponent.prototype.addressSearchControl;
    /**
     * @type {?}
     * @private
     */
    MatGoogleMapsAutocompleteComponent.prototype.mapsAPILoader;
    /**
     * @type {?}
     * @private
     */
    MatGoogleMapsAutocompleteComponent.prototype.ngZone;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF0LWdvb2dsZS1tYXBzLWF1dG9jb21wbGV0ZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYW5ndWxhci1tYXRlcmlhbC1leHRlbnNpb25zL2dvb2dsZS1tYXBzLWF1dG9jb21wbGV0ZS8iLCJzb3VyY2VzIjpbImxpYi9jb21wb25lbnQvbWF0LWdvb2dsZS1tYXBzLWF1dG9jb21wbGV0ZS5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUMsU0FBUyxFQUFFLFVBQVUsRUFBRSxZQUFZLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBVSxNQUFNLEVBQUUsU0FBUyxFQUFDLE1BQU0sZUFBZSxDQUFDO0FBQzVHLE9BQU8sRUFBQyxXQUFXLEVBQUUsVUFBVSxFQUFDLE1BQU0sZ0JBQWdCLENBQUM7QUFDdkQsT0FBTyxFQUFDLGFBQWEsRUFBQyxNQUFNLFdBQVcsQ0FBQztBQUN4QyxPQUFPLEVBQUMsMkJBQTJCLEVBQUMsTUFBTSxpRUFBaUUsQ0FBQzs7QUFNNUcsTUFBWSxVQUFVO0lBQ3BCLFFBQVEsWUFBYTtJQUNyQixJQUFJLFFBQVM7SUFDYixPQUFPLFdBQVk7SUFDbkIsTUFBTSxVQUFXO0VBQ2xCOztBQVFELE1BQU0sT0FBTyxrQ0FBa0M7Ozs7O0lBOEQ3QyxZQUFvQixhQUE0QixFQUM1QixNQUFjO1FBRGQsa0JBQWEsR0FBYixhQUFhLENBQWU7UUFDNUIsV0FBTSxHQUFOLE1BQU0sQ0FBUTtRQXpEbEMscUJBQWdCLEdBQUcsU0FBUyxDQUFDO1FBRzdCLG9CQUFlLEdBQUcsMEJBQTBCLENBQUM7UUFHN0Msc0JBQWlCLEdBQUcseUJBQXlCLENBQUM7UUFHOUMscUJBQWdCLEdBQUcsMEJBQTBCLENBQUM7UUFHOUMsZUFBVSxHQUF3QixVQUFVLENBQUMsUUFBUSxDQUFDO1FBc0J0RCx3QkFBbUIsR0FBd0IsRUFBRSxDQUFDO1FBRzlDLGFBQVEsR0FBOEMsSUFBSSxZQUFZLEVBQStCLENBQUM7UUFHdEcs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REFDc0Q7O0lBRXRELHFEQUM4Qjs7SUFFOUIscURBQzJCOztJQUUzQix5REFDc0I7O0lBRXRCLDBEQUN1Qjs7SUFFdkIsbURBQ2lCOztJQUdqQixrREFDYzs7SUFFZCxpRUFDOEM7O0lBRTlDLHNEQUNzRzs7SUFFdEcsb0VBQ29GOztJQUVwRixtRUFDdUY7O0lBRXZGLGdFQUMwRTs7Ozs7SUFFMUUsOERBQWlFOzs7OztJQUNqRSw4REFBMEY7O0lBRTFGLGtFQUdFOzs7OztJQUVVLDJEQUFvQzs7Ozs7SUFDcEMsb0RBQXNCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtDb21wb25lbnQsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE5nWm9uZSwgT25Jbml0LCBPdXRwdXQsIFZpZXdDaGlsZH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Zvcm1Db250cm9sLCBWYWxpZGF0b3JzfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge01hcHNBUElMb2FkZXJ9IGZyb20gJ0BhZ20vY29yZSc7XG5pbXBvcnQge01hdFZhbGlkYXRlQWRkcmVzc0RpcmVjdGl2ZX0gZnJvbSAnLi4vZGlyZWN0aXZlcy9hZGRyZXNzLXZhbGlkYXRvci9tYXQtYWRkcmVzcy12YWxpZGF0b3IuZGlyZWN0aXZlJztcbmltcG9ydCB7TG9jYXRpb259IGZyb20gJy4uL2ludGVyZmFjZXMvbG9jYXRpb24uaW50ZXJmYWNlJztcbmltcG9ydCB7R2VybWFuQWRkcmVzc30gZnJvbSAnLi4vaW50ZXJmYWNlcyc7XG5pbXBvcnQgUGxhY2VSZXN1bHQgPSBnb29nbGUubWFwcy5wbGFjZXMuUGxhY2VSZXN1bHQ7XG5pbXBvcnQgQXV0b2NvbXBsZXRlT3B0aW9ucyA9IGdvb2dsZS5tYXBzLnBsYWNlcy5BdXRvY29tcGxldGVPcHRpb25zO1xuXG5leHBvcnQgZW51bSBBcHBlYXJhbmNlIHtcbiAgU1RBTkRBUkQgPSAnc3RhbmRhcmQnLFxuICBGSUxMID0gJ2ZpbGwnLFxuICBPVVRMSU5FID0gJ291dGxpbmUnLFxuICBMRUdBQ1kgPSAnbGVnYWN5Jyxcbn1cblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnbWF0LWdvb2dsZS1tYXBzLWF1dG9jb21wbGV0ZScsXG4gIGV4cG9ydEFzOiAnbWF0R29vZ2xlTWFwc0F1dG9jb21wbGV0ZScsXG4gIHRlbXBsYXRlVXJsOiAnLi9tYXQtZ29vZ2xlLW1hcHMtYXV0b2NvbXBsZXRlLmNvbXBvbmVudC5odG1sJyxcbiAgc3R5bGVVcmxzOiBbJy4vbWF0LWdvb2dsZS1tYXBzLWF1dG9jb21wbGV0ZS5jb21wb25lbnQuc2NzcyddXG59KVxuZXhwb3J0IGNsYXNzIE1hdEdvb2dsZU1hcHNBdXRvY29tcGxldGVDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuXG4gIEBWaWV3Q2hpbGQoJ3NlYXJjaCcsIHtzdGF0aWM6IGZhbHNlfSlcbiAgcHVibGljIHNlYXJjaEVsZW1lbnRSZWY6IEVsZW1lbnRSZWY7XG5cbiAgQElucHV0KClcbiAgYWRkcmVzc0xhYmVsVGV4dCA9ICdBZGRyZXNzJztcblxuICBASW5wdXQoKVxuICBwbGFjZWhvbGRlclRleHQgPSAnUGxlYXNlIGVudGVyIHRoZSBhZGRyZXNzJztcblxuICBASW5wdXQoKVxuICByZXF1aXJlZEVycm9yVGV4dCA9ICdUaGUgYWRkcmVzcyBpcyByZXF1aXJlZCc7XG5cbiAgQElucHV0KClcbiAgaW52YWxpZEVycm9yVGV4dCA9ICdUaGUgYWRkcmVzcyBpcyBub3QgdmFsaWQnO1xuXG4gIEBJbnB1dCgpXG4gIGFwcGVhcmFuY2U6IHN0cmluZyB8IEFwcGVhcmFuY2UgPSBBcHBlYXJhbmNlLlNUQU5EQVJEO1xuXG4gIEBJbnB1dCgpXG4gIGFkZHJlc3M6IFBsYWNlUmVzdWx0IHwgc3RyaW5nO1xuXG4gIEBJbnB1dCgpXG4gIGNvdW50cnk6IHN0cmluZyB8IHN0cmluZ1tdO1xuXG4gIEBJbnB1dCgpXG4gIHBsYWNlSWRPbmx5PzogYm9vbGVhbjtcblxuICBASW5wdXQoKVxuICBzdHJpY3RCb3VuZHM/OiBib29sZWFuO1xuXG4gIEBJbnB1dCgpXG4gIHR5cGVzPzogc3RyaW5nW107XG4gIC8vIHR5cGVzOiBzdHJpbmdbXSA9IFsnYWRkcmVzcyddO1xuXG4gIEBJbnB1dCgpXG4gIHR5cGU/OiBzdHJpbmc7XG5cbiAgQElucHV0KClcbiAgYXV0b0NvbXBsZXRlT3B0aW9uczogQXV0b2NvbXBsZXRlT3B0aW9ucyA9IHt9O1xuXG4gIEBPdXRwdXQoKVxuICBvbkNoYW5nZTogRXZlbnRFbWl0dGVyPFBsYWNlUmVzdWx0IHwgc3RyaW5nIHwgbnVsbD4gPSBuZXcgRXZlbnRFbWl0dGVyPFBsYWNlUmVzdWx0IHwgc3RyaW5nIHwgbnVsbD4oKTtcblxuICBAT3V0cHV0KClcbiAgb25BdXRvY29tcGxldGVTZWxlY3RlZDogRXZlbnRFbWl0dGVyPFBsYWNlUmVzdWx0PiA9IG5ldyBFdmVudEVtaXR0ZXI8UGxhY2VSZXN1bHQ+KCk7XG5cbiAgQE91dHB1dCgpXG4gIG9uR2VybWFuQWRkcmVzc01hcHBlZDogRXZlbnRFbWl0dGVyPEdlcm1hbkFkZHJlc3M+ID0gbmV3IEV2ZW50RW1pdHRlcjxHZXJtYW5BZGRyZXNzPigpO1xuXG4gIEBPdXRwdXQoKVxuICBvbkxvY2F0aW9uU2VsZWN0ZWQ6IEV2ZW50RW1pdHRlcjxMb2NhdGlvbj4gPSBuZXcgRXZlbnRFbWl0dGVyPExvY2F0aW9uPigpO1xuXG4gIHByaXZhdGUgb25OZXdQbGFjZVJlc3VsdDogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gIHByaXZhdGUgYWRkcmVzc1ZhbGlkYXRvcjogTWF0VmFsaWRhdGVBZGRyZXNzRGlyZWN0aXZlID0gbmV3IE1hdFZhbGlkYXRlQWRkcmVzc0RpcmVjdGl2ZSgpO1xuXG4gIHB1YmxpYyBhZGRyZXNzU2VhcmNoQ29udHJvbDogRm9ybUNvbnRyb2wgPSBuZXcgRm9ybUNvbnRyb2woe3ZhbHVlOiBudWxsfSwgVmFsaWRhdG9ycy5jb21wb3NlKFtcbiAgICBWYWxpZGF0b3JzLnJlcXVpcmVkLFxuICAgIHRoaXMuYWRkcmVzc1ZhbGlkYXRvci52YWxpZGF0ZSgpXSlcbiAgKTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIG1hcHNBUElMb2FkZXI6IE1hcHNBUElMb2FkZXIsXG4gICAgICAgICAgICAgIHByaXZhdGUgbmdab25lOiBOZ1pvbmUpIHtcbiAgfVxuXG4gIG5nT25Jbml0KCk6IHZvaWQge1xuICAgIHRoaXMuYWRkcmVzc1ZhbGlkYXRvci5zdWJzY3JpYmUodGhpcy5vbk5ld1BsYWNlUmVzdWx0KTtcblxuICAgIGNvbnN0IG9wdGlvbnM6IEF1dG9jb21wbGV0ZU9wdGlvbnMgPSB7XG4gICAgICAvLyB0eXBlczogWydhZGRyZXNzJ10sXG4gICAgICAvLyBjb21wb25lbnRSZXN0cmljdGlvbnM6IHtjb3VudHJ5OiB0aGlzLmNvdW50cnl9LFxuICAgICAgcGxhY2VJZE9ubHk6IHRoaXMucGxhY2VJZE9ubHksXG4gICAgICBzdHJpY3RCb3VuZHM6IHRoaXMuc3RyaWN0Qm91bmRzLFxuICAgICAgLy8gdHlwZXM6IHRoaXMudHlwZXMsXG4gICAgICB0eXBlOiB0aGlzLnR5cGVcbiAgICB9O1xuXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLXVudXNlZC1leHByZXNzaW9uXG4gICAgdGhpcy5jb3VudHJ5ID8gb3B0aW9ucy5jb21wb25lbnRSZXN0cmljdGlvbnMgPSB7Y291bnRyeTogdGhpcy5jb3VudHJ5fSA6IG51bGw7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLXVudXNlZC1leHByZXNzaW9uXG4gICAgdGhpcy5jb3VudHJ5ID8gb3B0aW9ucy50eXBlcyA9IHRoaXMudHlwZXMgOiBudWxsO1xuXG4gICAgdGhpcy5hdXRvQ29tcGxldGVPcHRpb25zID0gT2JqZWN0LmFzc2lnbih0aGlzLmF1dG9Db21wbGV0ZU9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIHRoaXMuaW5pdEdvb2dsZU1hcHNBdXRvY29tcGxldGUoKTtcbiAgfVxuXG4gIHB1YmxpYyBpbml0R29vZ2xlTWFwc0F1dG9jb21wbGV0ZSgpIHtcbiAgICB0aGlzLm1hcHNBUElMb2FkZXJcbiAgICAgIC5sb2FkKClcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgY29uc3QgYXV0b2NvbXBsZXRlID0gbmV3IGdvb2dsZS5tYXBzLnBsYWNlcy5BdXRvY29tcGxldGUodGhpcy5zZWFyY2hFbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsIHRoaXMuYXV0b0NvbXBsZXRlT3B0aW9ucyk7XG4gICAgICAgIGF1dG9jb21wbGV0ZS5hZGRMaXN0ZW5lcigncGxhY2VfY2hhbmdlZCcsICgpID0+IHtcbiAgICAgICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgLy8gZ2V0IHRoZSBwbGFjZSByZXN1bHRcbiAgICAgICAgICAgIGNvbnN0IHBsYWNlOiBQbGFjZVJlc3VsdCA9IGF1dG9jb21wbGV0ZS5nZXRQbGFjZSgpO1xuXG4gICAgICAgICAgICBjb25zdCBnZXJtYW5BZGRyZXNzOiBHZXJtYW5BZGRyZXNzID0ge1xuICAgICAgICAgICAgICBnbUlEOiBwbGFjZS5pZCxcbiAgICAgICAgICAgICAgaWNvbjogcGxhY2UuaWNvbixcbiAgICAgICAgICAgICAgdXJsOiBwbGFjZS51cmwsXG4gICAgICAgICAgICAgIHBsYWNlSUQ6IHBsYWNlLnBsYWNlX2lkLFxuICAgICAgICAgICAgICBkaXNwbGF5QWRkcmVzczogcGxhY2UuZm9ybWF0dGVkX2FkZHJlc3MsXG4gICAgICAgICAgICAgIG5hbWU6IHBsYWNlLm5hbWUsXG4gICAgICAgICAgICAgIHZpY2luaXR5OiBwbGFjZS52aWNpbml0eSxcbiAgICAgICAgICAgICAgbG9jYWxpdHk6IHt9LFxuICAgICAgICAgICAgICBzdGF0ZToge30sXG4gICAgICAgICAgICAgIGNvdW50cnk6IHt9LFxuICAgICAgICAgICAgICBnZW9Mb2NhdGlvbjoge2xhdGl0dWRlOiAtMSwgbG9uZ2l0dWRlOiAtMX0sXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAocGxhY2UuZ2VvbWV0cnkgJiYgcGxhY2UuZ2VvbWV0cnkubG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgZ2VybWFuQWRkcmVzcy5nZW9Mb2NhdGlvbi5sYXRpdHVkZSA9IHBsYWNlLmdlb21ldHJ5LmxvY2F0aW9uLmxhdCgpO1xuICAgICAgICAgICAgICBnZXJtYW5BZGRyZXNzLmdlb0xvY2F0aW9uLmxvbmdpdHVkZSA9IHBsYWNlLmdlb21ldHJ5LmxvY2F0aW9uLmxuZygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwbGFjZS5hZGRyZXNzX2NvbXBvbmVudHMuZm9yRWFjaCh2YWx1ZSA9PiB7XG4gICAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlcy5pbmRleE9mKCdzdHJlZXRfbnVtYmVyJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIGdlcm1hbkFkZHJlc3Muc3RyZWV0TnVtYmVyID0gTnVtYmVyKHZhbHVlLnNob3J0X25hbWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlcy5pbmRleE9mKCdyb3V0ZScpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBnZXJtYW5BZGRyZXNzLnN0cmVldE5hbWUgPSB2YWx1ZS5sb25nX25hbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHZhbHVlLnR5cGVzLmluZGV4T2YoJ3Bvc3RhbF9jb2RlJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIGdlcm1hbkFkZHJlc3MucG9zdGFsQ29kZSA9IE51bWJlcih2YWx1ZS5zaG9ydF9uYW1lKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodmFsdWUudHlwZXMuaW5kZXhPZignc3VibG9jYWxpdHknKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgZ2VybWFuQWRkcmVzcy5zdWJsb2NhbGl0eSA9IHZhbHVlLmxvbmdfbmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodmFsdWUudHlwZXMuaW5kZXhPZignbG9jYWxpdHknKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgZ2VybWFuQWRkcmVzcy5sb2NhbGl0eS5sb25nID0gdmFsdWUubG9uZ19uYW1lO1xuICAgICAgICAgICAgICAgIGdlcm1hbkFkZHJlc3MubG9jYWxpdHkuc2hvcnQgPSB2YWx1ZS5zaG9ydF9uYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlcy5pbmRleE9mKCdhZG1pbmlzdHJhdGl2ZV9hcmVhX2xldmVsXzEnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgZ2VybWFuQWRkcmVzcy5zdGF0ZS5sb25nID0gdmFsdWUubG9uZ19uYW1lO1xuICAgICAgICAgICAgICAgIGdlcm1hbkFkZHJlc3Muc3RhdGUuc2hvcnQgPSB2YWx1ZS5zaG9ydF9uYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlcy5pbmRleE9mKCdjb3VudHJ5JykgPiAtMSkge1xuICAgICAgICAgICAgICAgIGdlcm1hbkFkZHJlc3MuY291bnRyeS5sb25nID0gdmFsdWUubG9uZ19uYW1lO1xuICAgICAgICAgICAgICAgIGdlcm1hbkFkZHJlc3MuY291bnRyeS5zaG9ydCA9IHZhbHVlLnNob3J0X25hbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHZhbHVlLnR5cGVzLmluZGV4T2YoJ2FkbWluaXN0cmF0aXZlX2FyZWFfbGV2ZWxfMycpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBnZXJtYW5BZGRyZXNzLmxvY2FsaXR5LnNob3J0ID0gdmFsdWUuc2hvcnRfbmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMub25HZXJtYW5BZGRyZXNzTWFwcGVkLmVtaXQoZ2VybWFuQWRkcmVzcyk7XG5cbiAgICAgICAgICAgIGlmICghcGxhY2UucGxhY2VfaWQgfHwgcGxhY2UuZ2VvbWV0cnkgPT09IHVuZGVmaW5lZCB8fCBwbGFjZS5nZW9tZXRyeSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBwbGFjZSByZXN1bHQgaXMgbm90IHZhbGlkXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIHNob3cgZGlhbG9nIHRvIHNlbGVjdCBhIGFkZHJlc3MgZnJvbSB0aGUgaW5wdXRcbiAgICAgICAgICAgICAgLy8gZW1pdCBmYWlsZWQgZXZlbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWRkcmVzcyA9IHBsYWNlLmZvcm1hdHRlZF9hZGRyZXNzO1xuICAgICAgICAgICAgdGhpcy5vbkF1dG9jb21wbGV0ZVNlbGVjdGVkLmVtaXQocGxhY2UpO1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ29uQXV0b2NvbXBsZXRlU2VsZWN0ZWQgLT4gJywgcGxhY2UpO1xuICAgICAgICAgICAgdGhpcy5vbkxvY2F0aW9uU2VsZWN0ZWQuZW1pdChcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGxhdGl0dWRlOiBwbGFjZS5nZW9tZXRyeS5sb2NhdGlvbi5sYXQoKSxcbiAgICAgICAgICAgICAgICBsb25naXR1ZGU6IHBsYWNlLmdlb21ldHJ5LmxvY2F0aW9uLmxuZygpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycikgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gIH1cblxuICBwdWJsaWMgb25RdWVyeShldmVudDogYW55KSB7XG4gICAgLy8gY29uc29sZS5sb2coJ29uQ2hhbmdlKCknLCBldmVudCk7XG4gICAgdGhpcy5vbkNoYW5nZS5lbWl0KHRoaXMuYWRkcmVzcyk7XG4gIH1cblxuICBwcml2YXRlIHJlc2V0QWRkcmVzcygpIHtcbiAgICB0aGlzLmFkZHJlc3MgPSBudWxsO1xuICAgIHRoaXMuYWRkcmVzc1NlYXJjaENvbnRyb2wudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSgpO1xuICB9XG5cbn1cbiJdfQ==